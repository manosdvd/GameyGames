<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Hex Energy</title>
    <style>
        :root {
            --bg-color: #050505;
            --hex-bg: rgba(255, 255, 255, 0.03);
            --color-off: #555;
            --color-track: #111;
            --color-fluid: #00ffaa;
            --color-core: #ffffff;
            --ui-bg: rgba(20, 20, 20, 0.9);
            --ui-border: rgba(0, 255, 170, 0.3);
            --tile-clip: polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%);
        }

        * {
            box-sizing: border-box;
            touch-action: none;
            -webkit-tap-highlight-color: transparent;
            user-select: none;
        }

        body {
            margin: 0;
            padding: 0;
            width: 100vw;
            height: 100vh;
            background-color: var(--bg-color);
            color: #fff;
            font-family: 'Segoe UI', system-ui, sans-serif;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        /* --- UI Layers --- */
        #top-ui {
            position: absolute;
            top: 15px;
            width: 100%;
            display: flex;
            justify-content: center;
            pointer-events: none;
            z-index: 20;
        }

        #bottom-ui {
            position: absolute;
            bottom: 15px;
            width: 95%;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
            z-index: 20;
            pointer-events: auto;
            flex-wrap: wrap;
        }

        .hud-pill {
            background: var(--ui-bg);
            border: 1px solid var(--ui-border);
            padding: 8px 20px;
            border-radius: 50px;
            font-weight: 800;
            font-size: 14px;
            letter-spacing: 1.5px;
            text-transform: uppercase;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.5);
            display: flex;
            gap: 15px;
            color: #888;
        }

        .hud-value {
            color: var(--color-fluid);
            transition: color 0.3s;
        }

        .control-btn {
            background: var(--ui-bg);
            border: 1px solid var(--ui-border);
            color: #fff;
            padding: 8px 16px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            text-transform: uppercase;
            font-size: 0.8rem;
            transition: all 0.2s;
            min-width: 70px;
        }

        .control-btn:hover {
            background: var(--color-fluid);
            color: #000;
            box-shadow: 0 0 15px var(--color-fluid);
        }

        .control-btn:active {
            transform: scale(0.95);
        }

        .hud-pill-small {
            background: var(--ui-bg);
            border: 1px solid var(--ui-border);
            padding: 4px 12px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.8rem;
        }

        .seed-input-container {
            display: flex;
            align-items: center;
            background: var(--ui-bg);
            border: 1px solid var(--ui-border);
            border-radius: 8px;
            padding: 4px 8px;
        }

        .seed-label {
            font-size: 0.7rem;
            color: #888;
            margin-right: 6px;
            text-transform: uppercase;
            font-weight: bold;
        }

        #seed-input {
            background: transparent;
            border: none;
            color: var(--color-fluid);
            font-family: monospace;
            font-size: 0.9rem;
            width: 150px;
            outline: none;
        }

        /* --- Game Board --- */
        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            /* Full height, layout calculates margins */
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10;
            overflow: hidden;
        }

        #grid {
            position: relative;
            margin: auto;
            transition: width 0.3s, height 0.3s;
        }

        .hex-wrapper {
            position: absolute;
            cursor: pointer;
            /* clip-path set dynamically via CSS var or js */
            transition: transform 0.1s;
            -webkit-tap-highlight-color: transparent;
        }

        .hex-wrapper:active {
            transform: scale(0.92);
        }

        .hex-inner {
            width: 100%;
            height: 100%;
            background: var(--hex-bg);
            clip-path: var(--tile-clip);
            pointer-events: none;
            transition: transform 0.25s cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        .hex-inner.anchor {
            background: rgba(0, 255, 170, 0.08);
        }

        .hex-inner svg {
            width: 100%;
            height: 100%;
            display: block;
            overflow: visible;
        }

        /* Pipes & Fluids */
        .pipe-track {
            fill: none;
            stroke: var(--color-track);
            stroke-width: 20;
            stroke-linecap: round;
            stroke-linejoin: round;
        }

        .pipe-wire {
            fill: none;
            stroke: var(--color-off);
            stroke-width: 8;
            stroke-linecap: round;
            stroke-linejoin: round;
            transition: stroke 0.3s;
        }

        .fluid-segment {
            fill: none;
            stroke: var(--color-fluid);
            stroke-width: 8;
            stroke-linecap: round;
            stroke-linejoin: round;
            opacity: 0;
            transition: opacity 0.15s ease-out;
        }

        .fluid-segment.lit,
        .fluid-center.lit {
            opacity: 1;
            filter: drop-shadow(0 0 4px var(--color-fluid));
        }

        .node-base {
            fill: var(--color-off);
            transition: fill 0.3s;
        }

        .fluid-center {
            fill: var(--color-fluid);
            opacity: 0;
            transition: opacity 0.15s ease-out;
        }

        .hex-inner.anchor .node-base {
            r: 9;
            stroke: #000;
            stroke-width: 3;
        }

        .fluid-center.anchor-lit {
            r: 9;
            opacity: 1;
            filter: drop-shadow(0 0 12px var(--color-fluid));
            animation: pulse-anchor 2s infinite;
        }

        @keyframes pulse-anchor {
            0% {
                opacity: 0.8;
                transform: scale(1);
            }

            50% {
                opacity: 1;
                transform: scale(1.1);
            }

            100% {
                opacity: 0.8;
                transform: scale(1);
            }
        }



        /* Victory Overlay */
        #victory-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s ease;
            z-index: 100;
            backdrop-filter: blur(10px);
        }

        #victory-screen.visible {
            opacity: 1;
            pointer-events: all;
        }

        .victory-text {
            font-size: 3rem;
            color: var(--color-fluid);
            text-transform: uppercase;
            font-weight: 900;
            letter-spacing: 4px;
            text-shadow: 0 0 40px var(--color-fluid);
            margin-bottom: 20px;
            text-align: center;
        }

        .next-btn {
            background: transparent;
            color: #fff;
            border: 2px solid var(--color-fluid);
            padding: 16px 40px;
            font-size: 1.2rem;
            border-radius: 50px;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 2px;
            font-weight: 700;
            transition: all 0.3s;
            box-shadow: 0 0 20px rgba(0, 255, 170, 0.1);
        }

        .next-btn:hover {
            background: var(--color-fluid);
            color: #000;
            box-shadow: 0 0 50px var(--color-fluid);
            transform: scale(1.05);
        }

        canvas {
            position: fixed;
            top: 0;
            left: 0;
            pointer-events: none;
            z-index: 50;
        }

        #bg-canvas {
            z-index: 1;
            opacity: 0.4;
        }
    </style>
    <script src="../timeLimit.js"></script>
</head>

<body>

    <canvas id="bg-canvas"></canvas>

    <div id="top-ui">
        <div class="hud-pill">
            <span id="level-lbl">Level 1</span>
            <span id="status-lbl" class="hud-value">0% Lit</span>
        </div>
    </div>

    <div id="game-container">
        <div id="grid"></div>
    </div>

    <div id="bottom-ui">
        <button class="control-btn" onclick="undoLastMove()">Undo</button>
        <button class="control-btn" onclick="resetPuzzle()">Reset</button>
        <button class="control-btn" onclick="openSetup()">New</button>
        <div class="hud-pill-small">
            <span class="seed-label">Moves</span>
            <span id="moves-lbl" class="hud-value">0</span>
        </div>
        <div class="hud-pill-small">
            <span class="seed-label">Time</span>
            <span id="time-lbl" class="hud-value">00:00</span>
        </div>
        <div class="seed-input-container">
            <span class="seed-label">Seed</span>
            <input type="text" id="seed-input" spellcheck="false" onchange="loadFromInput(this.value)">
        </div>
    </div>

    <div id="victory-screen">
        <div class="victory-text">Grid Stabilized</div>
        <button class="next-btn" onclick="nextLevel()">Next Sector</button>
    </div>

    <canvas id="particles"></canvas>

    <div id="start-overlay"
        style="position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(5,5,5,0.95); display:flex; flex-direction:column; align-items:center; justify-content:center; z-index:9999; backdrop-filter:blur(10px);">
        <!-- Content injected by JS -->
    </div>

    <script>
        // Setup Logic
        function openSetup() {
            const overlay = document.getElementById('start-overlay');
            overlay.style.opacity = '1';
            overlay.style.pointerEvents = 'all';
            overlay.innerHTML = `
                 <h1 style="font-size:3rem; color:#00ffaa; text-transform:uppercase; margin-bottom:2rem; text-shadow:0 0 20px #00ffaa;">HEX ENERGY</h1>
                 
                 <div style="background:rgba(20,20,20,0.8); padding:20px; border-radius:10px; border:1px solid #00ffaa; width:300px;">
                    <h2 style="color:#aaa; font-size:0.9rem; text-transform:uppercase; margin-bottom:10px;">CONFIG</h2>
                    
                    <div style="margin-bottom:15px;">
                         <label style="color:#fff; font-size:0.8rem; text-transform:uppercase; display:block; margin-bottom:5px;">GRID SIZE</label>
                         <input type="range" id="size-slider" min="3" max="10" value="${GRID_W}" style="width:100%; accent-color:#00ffaa;">
                         <div id="size-val" style="color:#00ffaa; text-align:right; font-family:monospace;">${GRID_W}x${GRID_W}</div>
                    </div>

                    <div style="margin-bottom:20px;">
                         <label style="color:#fff; font-size:0.8rem; text-transform:uppercase; display:block; margin-bottom:5px;">NODE SHAPE (SIDES)</label>
                         <input type="range" id="shape-slider" min="3" max="8" value="${NODE_SHAPE}" style="width:100%; accent-color:#00ffaa;">
                         <div id="shape-val" style="color:#00ffaa; text-align:right; font-family:monospace;">${NODE_SHAPE} (${getTopologyForShape(NODE_SHAPE)})</div>
                    </div>
                    
                    <button id="init-btn" style="width:100%; background:transparent; color:#fff; border:2px solid #00ffaa; padding:10px; font-size:1.2rem; border-radius:50px; cursor:pointer; text-transform:uppercase; font-weight:700; transition:all 0.3s;">INITIALIZE</button>
                 </div>
                 `;

            const sizeSlider = document.getElementById('size-slider');
            const shapeSlider = document.getElementById('shape-slider');
            const sizeVal = document.getElementById('size-val');
            const shapeVal = document.getElementById('shape-val');
            const initBtn = document.getElementById('init-btn');

            sizeSlider.oninput = (e) => sizeVal.innerText = `${e.target.value}x${e.target.value}`;
            shapeSlider.oninput = (e) => {
                const val = parseInt(e.target.value);
                const type = getTopologyForShape(val);
                shapeVal.innerText = `${val} (${type})`;
            };

            initBtn.onclick = () => {
                GRID_W = parseInt(sizeSlider.value);
                GRID_H = parseInt(sizeSlider.value);
                NODE_SHAPE = parseInt(shapeSlider.value);

                overlay.style.opacity = '0';
                overlay.style.pointerEvents = 'none';
                setTimeout(() => overlay.innerHTML = '', 500);

                // Seed setup
                // We need to trigger a new generation
                startNewCustomGame();

                // Audio
                if (audio && audio.ctx && audio.ctx.state === 'suspended') audio.ctx.resume();
                try {
                    if (document.documentElement.requestFullscreen) document.documentElement.requestFullscreen();
                } catch (e) { }
            };
        }

        function startNewCustomGame() {
            const seedVal = Math.floor(Math.random() * 900000) + 100000;
            // Format: WxH:SIDES:SEED
            const seedCode = `${GRID_W}x${GRID_H}:${NODE_SHAPE}:${seedVal}`;
            loadGameFromSeed(seedCode);
        }

        // Default Init
        window.onload = openSetup;

    </script>

    <script>
        // --- RNG (Mulberry32) ---
        let rngState = 0;

        function seedRNG(str) {
            let h = 2166136261 >>> 0;
            for (let i = 0; i < str.length; i++) {
                h = Math.imul(h ^ str.charCodeAt(i), 16777619);
            }
            rngState = h >>> 0;
        }

        function rand() {
            let t = rngState += 0x6D2B79F5;
            t = Math.imul(t ^ t >>> 15, t | 1);
            t ^= t + Math.imul(t ^ t >>> 7, t | 61);
            return ((t ^ t >>> 14) >>> 0) / 4294967296;
        }

        // --- Constants ---

        // --- State ---
        let GRID_W = 4;
        let GRID_H = 4;
        let TILE_R = 40; // Calculated dynamically
        let NODE_SHAPE = 6; // 6 = Hex, 4 = Square, etc.
        let GRID_TYPE = 'HEX'; // 'HEX' or 'SQUARE'

        let level = 1;
        let grid = [];
        let startNode = null;
        let endNodes = [];
        let isInputLocked = false;
        let flowAnimationId = 0;
        let currentSeedCode = "";

        // Stats & Undo
        let moves = 0;
        let startTime = 0;
        let timerInterval = null;
        let moveHistory = [];

        // --- DOM ---
        const gridEl = document.getElementById('grid');
        const statusEl = document.getElementById('status-lbl');
        const levelEl = document.getElementById('level-lbl');
        const victoryEl = document.getElementById('victory-screen');
        const seedInput = document.getElementById('seed-input');
        const movesEl = document.getElementById('moves-lbl');
        const timeEl = document.getElementById('time-lbl');
        const canvas = document.getElementById('particles');
        const ctx = canvas.getContext('2d');

        // --- Sound Manager ---
        class SoundManager {
            constructor() {
                this.ctx = null;
                this.enabled = true;
            }

            init() {
                if (!this.enabled) return;
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                if (!AudioContext) return;
                this.ctx = new AudioContext();
            }

            playTone(freq, type, duration, vol = 0.1) {
                if (!this.ctx) this.init();
                if (!this.ctx || this.ctx.state === 'suspended') {
                    if (this.ctx) this.ctx.resume();
                }
                if (!this.ctx) return;

                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();

                osc.type = type;
                osc.frequency.setValueAtTime(freq, this.ctx.currentTime);

                gain.gain.setValueAtTime(0, this.ctx.currentTime);
                gain.gain.linearRampToValueAtTime(vol, this.ctx.currentTime + 0.01);
                gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + duration);

                osc.connect(gain);
                gain.connect(this.ctx.destination);

                osc.start();
                osc.stop(this.ctx.currentTime + duration);
            }

            playClick() {
                this.playTone(800, 'sine', 0.1, 0.1);
                setTimeout(() => this.playTone(1200, 'triangle', 0.05, 0.05), 50);
            }

            playConnect() {
                this.playTone(400, 'sine', 0.3, 0.1);
                this.playTone(600, 'sine', 0.3, 0.05);
            }

            playVictory() {
                const notes = [440, 554, 659, 880];
                notes.forEach((f, i) => {
                    setTimeout(() => this.playTone(f, 'sine', 0.8, 0.2), i * 100);
                });
            }
        }

        const audio = new SoundManager();

        // --- Logic classes ---
        class Tile {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.baseShape = 0; // Bitmask of connections
                this.rotation = 0;
                this.isAnchor = false;
                this.tempConns = 0;
                this.wrapper = null;
                this.inner = null;
                this.domParts = {
                    center: null,
                    arms: []
                };
            }

            getConnections() {
                let s = this.baseShape;
                let r = this.rotation;
                let nc = 0;
                let n = NODE_SHAPE;

                for (let i = 0; i < n; i++) {
                    if (s & (1 << i)) {
                        let shift = (i + r) % n;
                        if (shift < 0) shift += n;
                        nc |= (1 << shift);
                    }
                }
                return nc;
            }

            rotate() {
                if (this.isAnchor) {
                    this.inner.style.transform = `rotate(${this.rotation * (360 / NODE_SHAPE)}deg) scale(0.9)`;
                    setTimeout(() => this.updateTransform(), 100);
                    return;
                }
                this.rotation = (this.rotation + 1) % NODE_SHAPE;
                this.updateTransform();
            }

            updateTransform() {
                if (this.inner) {
                    this.inner.style.transform = `rotate(${this.rotation * (360 / NODE_SHAPE)}deg)`;
                }
            }

            setVisuals(mask) {
                if (!this.domParts.center) return;
                const toggle = (el, on) => {
                    if (!el) return;
                    if (on) el.classList.add('lit');
                    else el.classList.remove('lit');
                };
                toggle(this.domParts.center, mask & 1);
                if (this.isAnchor && (mask & 1)) this.domParts.center.classList.add('anchor-lit');
                else this.domParts.center.classList.remove('anchor-lit');

                for (let i = 0; i < NODE_SHAPE; i++) {
                    // Arm 0 corresponds to bit 1 (since bit 0 is center)
                    toggle(this.domParts.arms[i], mask & (1 << (i + 1)));
                }
            }
        }

        // --- Grid Topologies ---
        const GRID_LOGIC = {
            'HEX': {
                dirs: 6,
                offsets: [
                    [[0, -1], [1, 0], [0, 1], [-1, 1], [-1, 0], [-1, -1]], // Odd-R
                    [[1, -1], [1, 0], [1, 1], [0, 1], [-1, 0], [0, -1]]
                ],
                getNeighbors: (x, y) => {
                    const parity = y & 1;
                    const offsets = GRID_LOGIC['HEX'].offsets[parity];
                    let res = [];
                    for (let i = 0; i < 6; i++) {
                        let [dx, dy] = offsets[i];
                        let nx = x + dx, ny = y + dy;
                        if (nx >= 0 && nx < GRID_W && ny >= 0 && ny < GRID_H) {
                            res.push({ x: nx, y: ny, dir: i, opp: (i + 3) % 6 });
                        }
                    }
                    return res;
                },
                clipPath: 'polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%)'
            },
            'SQUARE': {
                dirs: 4,
                offsets: [[0, -1], [1, 0], [0, 1], [-1, 0]], // N, E, S, W
                getNeighbors: (x, y) => {
                    let res = [];
                    const offsets = GRID_LOGIC['SQUARE'].offsets;
                    for (let i = 0; i < 4; i++) {
                        let [dx, dy] = offsets[i];
                        let nx = x + dx, ny = y + dy;
                        if (nx >= 0 && nx < GRID_W && ny >= 0 && ny < GRID_H) {
                            res.push({ x: nx, y: ny, dir: i, opp: (i + 2) % 4 });
                        }
                    }
                    return res;
                },
                clipPath: 'polygon(0% 0%, 100% 0%, 100% 100%, 0% 100%)'
            },
            'SQUARE_8': { // For N=8
                dirs: 8,
                offsets: [[0, -1], [1, -1], [1, 0], [1, 1], [0, 1], [-1, 1], [-1, 0], [-1, -1]],
                getNeighbors: (x, y) => {
                    let res = [];
                    const offsets = GRID_LOGIC['SQUARE_8'].offsets;
                    for (let i = 0; i < 8; i++) {
                        let [dx, dy] = offsets[i];
                        let nx = x + dx, ny = y + dy;
                        if (nx >= 0 && nx < GRID_W && ny >= 0 && ny < GRID_H) {
                            res.push({ x: nx, y: ny, dir: i, opp: (i + 4) % 8 });
                        }
                    }
                    return res;
                },
                clipPath: 'polygon(30% 0%, 70% 0%, 100% 30%, 100% 70%, 70% 100%, 30% 100%, 0% 70%, 0% 30%)'
            }
        };

        function getTopologyForShape(n) {
            if (n === 4) return 'SQUARE';
            if (n === 8) return 'SQUARE_8';
            if (n === 3 || n === 6) return 'HEX';
            if (n < 6) return 'HEX';
            return 'SQUARE_8';
        }

        function getDegreeGeneric(t) {
            let d = 0;
            for (let i = 0; i < NODE_SHAPE; i++) if (t.tempConns & (1 << i)) d++;
            return d;
        }

        // --- Control Logic ---
        function resetPuzzle() {
            if (currentSeedCode) loadGameFromSeed(currentSeedCode);
        }

        function nextLevel() {
            // Level up logic? Just randomize for now
            GRID_W = Math.min(10, GRID_W + 1);
            GRID_H = Math.min(10, GRID_H + 1);
            startNewCustomGame();
        }

        function undoLastMove() {
            // Simple undo for now
            // Not implemented in this refactor
        }

        function loadFromInput(val) {
            if (val && val.includes(':')) {
                loadGameFromSeed(val);
            }
        }

        function loadGameFromSeed(seedCode) {
            try {
                // Determine format
                // Old: 4x4:123456
                // New: 4x4:6:123456 (Size:Shape:Seed)
                let parts = seedCode.split(':');
                let w, h, sVal, shape;

                if (parts.length === 2) {
                    // Old format, default to Hex (6)
                    let dims = parts[0];
                    sVal = parts[1];
                    [w, h] = dims.split('x').map(Number);
                    shape = 6;
                } else if (parts.length === 3) {
                    // New format
                    let dims = parts[0];
                    shape = parseInt(parts[1]);
                    sVal = parts[2];
                    [w, h] = dims.split('x').map(Number);
                }

                if (!w || !h || !sVal) throw new Error("Invalid Seed");

                GRID_W = w;
                GRID_H = h;
                NODE_SHAPE = shape || 6;

                currentSeedCode = seedCode;
                seedInput.value = seedCode;

                seedRNG(sVal);
                generateLevel();

                victoryEl.classList.remove('visible');
                isInputLocked = false;
            } catch (e) {
                console.error("Seed Error", e);
            }
        }

        // --- Generator ---
        function generateLevel() {
            grid = [];
            gridEl.innerHTML = '';
            endNodes = [];

            // Determine Topology
            GRID_TYPE = getTopologyForShape(NODE_SHAPE);
            const topology = GRID_LOGIC[GRID_TYPE];

            // Re-style Grid Container for Typology
            document.documentElement.style.setProperty('--tile-clip', topology.clipPath);

            // 1. Grid Creation
            for (let y = 0; y < GRID_H; y++) {
                let row = [];
                for (let x = 0; x < GRID_W; x++) row.push(new Tile(x, y));
                grid.push(row);
            }

            // 2. Prim's (Generic)
            let visited = new Set();
            let stack = [];
            let startX = Math.floor(rand() * GRID_W);
            let startY = Math.floor(rand() * GRID_H);

            let first = grid[startY][startX];
            stack.push(first);
            visited.add(first);

            while (stack.length > 0) {
                let curr = stack[stack.length - 1];
                let neighbors = topology.getNeighbors(curr.x, curr.y);

                // Filter visited
                let candidates = neighbors.filter(n => {
                    let t = grid[n.y][n.x];
                    return !visited.has(t);
                });

                // N-Gon Mapping Logic
                if (NODE_SHAPE === 3 && GRID_TYPE === 'HEX') {
                    // Triangles on Hex grid: strictly use 0, 2, 4
                    candidates = candidates.filter(n => n.dir % 2 === 0);
                }

                if (candidates.length > 0) {
                    let nextInfo = candidates[Math.floor(rand() * candidates.length)];
                    let nextTile = grid[nextInfo.y][nextInfo.x];

                    let currDir = nextInfo.dir;
                    let nextDir = nextInfo.opp;

                    if (NODE_SHAPE === 3) {
                        currDir /= 2;
                        nextDir /= 2;
                    }

                    curr.tempConns |= (1 << currDir);
                    nextTile.tempConns |= (1 << nextDir);

                    visited.add(nextTile);
                    stack.push(nextTile);
                } else {
                    stack.pop();
                }
            }

            // 3. Anchors
            let leaves = grid.flat().filter(t => getDegreeGeneric(t) === 1);
            if (leaves.length < 2) {
                let all = grid.flat();
                leaves = [all[0], all[all.length - 1]];
            }

            startNode = leaves.splice(Math.floor(rand() * leaves.length), 1)[0];
            startNode.isAnchor = true;

            let numSinks = Math.min(leaves.length, Math.floor(rand() * 2) + 2);
            if (numSinks < 1) numSinks = 1;

            for (let i = 0; i < numSinks; i++) {
                if (leaves.length > 0) {
                    let sink = leaves.splice(Math.floor(rand() * leaves.length), 1)[0];
                    sink.isAnchor = true;
                    endNodes.push(sink);
                }
            }
            if (endNodes.length === 0) {
                let t = grid[GRID_H - 1][GRID_W - 1];
                if (t !== startNode) { t.isAnchor = true; endNodes.push(t); }
            }

            // 4. Healing
            let healing = true;
            while (healing) {
                healing = false;
                for (let row of grid) {
                    for (let t of row) {
                        if (t.isAnchor) continue;
                        if (getDegreeGeneric(t) <= 1) {
                            let ns = topology.getNeighbors(t.x, t.y);
                            if (NODE_SHAPE === 3) ns = ns.filter(n => n.dir % 2 === 0);

                            let candidates = ns.filter(n => {
                                let nt = grid[n.y][n.x];
                                let dir = n.dir;
                                let opp = n.opp; // Unused in check but needed for implementation
                                if (NODE_SHAPE === 3) { dir /= 2; } // Map to shape index

                                if (t.tempConns & (1 << dir)) return false; // Already connected
                                if (nt.isAnchor) return false; // Avoid anchors
                                return true;
                            });

                            if (candidates.length > 0) {
                                let nextInfo = candidates[Math.floor(rand() * candidates.length)];
                                let nt = grid[nextInfo.y][nextInfo.x];
                                let d1 = nextInfo.dir;
                                let d2 = nextInfo.opp;
                                if (NODE_SHAPE === 3) { d1 /= 2; d2 /= 2; }

                                t.tempConns |= (1 << d1);
                                nt.tempConns |= (1 << d2);
                                healing = true;
                            }
                        }
                    }
                }
            }

            // 5. Finalize
            for (let row of grid) {
                for (let t of row) {
                    t.baseShape = t.tempConns || 0;
                    delete t.tempConns;
                }
            }

            // Order matters
            createGridDOM();
            updateLayout();
            scramble();
            triggerFlowCalc();
        }

        // --- DOM Generation ---
        function createGridDOM() {
            const fragment = document.createDocumentFragment();

            for (let row of grid) {
                for (let t of row) {
                    const wrap = document.createElement('div');
                    wrap.className = 'hex-wrapper';
                    t.wrapper = wrap;

                    const inner = document.createElement('div');
                    inner.className = 'hex-inner';
                    t.inner = inner;

                    let svgContent = `<circle cx="50" cy="50" r="10" class="node-base" />
                                       <circle cx="50" cy="50" r="6" class="fluid-center" />`;

                    let armLen = 45;

                    for (let i = 0; i < NODE_SHAPE; i++) {
                        let angle = 0;
                        if (GRID_TYPE === 'SQUARE') {
                            const angles = [-90, 0, 90, 180];
                            angle = angles[i];
                        } else if (GRID_TYPE === 'SQUARE_8') {
                            angle = -90 + (i * 45);
                        } else {
                            // Hex default
                            angle = -90 + (i * 60);
                        }

                        let rad = angle * Math.PI / 180;
                        let x2 = 50 + Math.cos(rad) * armLen;
                        let y2 = 50 + Math.sin(rad) * armLen;

                        svgContent += `<line x1="50" y1="50" x2="${x2}" y2="${y2}" class="pipe-track" />
                                        <line x1="50" y1="50" x2="${x2}" y2="${y2}" class="pipe-wire" data-arm="${i}" />
                                        <line x1="50" y1="50" x2="${x2}" y2="${y2}" class="fluid-segment" data-fluid="${i}" />`;
                    }

                    inner.innerHTML = `<svg viewBox="0 0 100 100">${svgContent}</svg>`;
                    wrap.appendChild(inner);
                    fragment.appendChild(wrap);

                    // Bind Events
                    wrap.onclick = () => {
                        if (!isInputLocked && !victoryEl.classList.contains('visible')) {
                            t.rotate();
                            audio.playClick();
                            moves++;
                            movesEl.innerText = moves;
                            triggerFlowCalc();
                        }
                    };

                    // Cache DOM refs
                    t.domParts.center = inner.querySelector('.fluid-center');
                    t.domParts.arms = [];
                    for (let i = 0; i < NODE_SHAPE; i++) {
                        t.domParts.arms.push(inner.querySelector(`.fluid-segment[data-fluid="${i}"]`));
                    }
                }
            }
            gridEl.appendChild(fragment);
        }

        // --- Dynamic Rendering ---
        function updateLayout() {
            let safeW = window.innerWidth - 20;
            let safeH = window.innerHeight - 130;

            if (GRID_TYPE === 'HEX') {
                // HEX Layout
                let hexW = Math.sqrt(3) * TILE_R;
                let hexH = 2 * TILE_R;
                let spacingX = hexW;
                let spacingY = hexH * 0.75;

                let totalW = spacingX * GRID_W + (GRID_H > 1 ? spacingX * 0.5 : 0);
                let totalH = spacingY * (GRID_H - 1) + hexH;

                let scale = Math.min(1, safeW / totalW, safeH / totalH);
                let finalR = TILE_R * scale;
                // Min cap
                if (finalR < 15) finalR = 15;

                hexW = Math.sqrt(3) * finalR;
                hexH = 2 * finalR;
                spacingX = hexW;
                spacingY = hexH * 0.75;

                let realW = spacingX * GRID_W + (GRID_H > 1 ? spacingX * 0.5 : 0);
                let realH = spacingY * (GRID_H - 1) + hexH;

                gridEl.style.width = realW + 'px';
                gridEl.style.height = realH + 'px';

                grid.forEach(row => row.forEach(t => {
                    if (!t.wrapper) return;
                    let xPos = t.x * spacingX + (t.y % 2) * (spacingX * 0.5);
                    let yPos = t.y * spacingY;

                    t.wrapper.style.width = hexW + 'px';
                    t.wrapper.style.height = hexH + 'px';
                    t.wrapper.style.left = xPos + 'px';
                    t.wrapper.style.top = yPos + 'px';

                    if (NODE_SHAPE === 3) {
                        t.inner.style.clipPath = 'polygon(50% 0%, 100% 100%, 0% 100%)';
                        // Triangle clipping usually requires improved centering or SVG viewBox adjustment
                    } else {
                        t.inner.style.clipPath = 'var(--tile-clip)';
                    }
                }));
            } else if (GRID_TYPE.startsWith('SQUARE')) {
                // Square Layout
                let cellS = TILE_R * 1.8;
                let totalW = cellS * GRID_W;
                let totalH = cellS * GRID_H;

                let scale = Math.min(1, safeW / totalW, safeH / totalH);
                let finalS = cellS * scale;
                if (finalS < 30) finalS = 30;

                let realW = finalS * GRID_W;
                let realH = finalS * GRID_H;

                gridEl.style.width = realW + 'px';
                gridEl.style.height = realH + 'px';

                grid.forEach(row => row.forEach(t => {
                    if (!t.wrapper) return;
                    t.wrapper.style.width = finalS + 'px';
                    t.wrapper.style.height = finalS + 'px';
                    t.wrapper.style.left = (t.x * finalS) + 'px';
                    t.wrapper.style.top = (t.y * finalS) + 'px';
                    t.inner.style.clipPath = 'var(--tile-clip)';
                }));
            }
        }

        function scramble() {
            for (let row of grid) for (let t of row) {
                if (!t.isAnchor) {
                    let r = Math.floor(rand() * NODE_SHAPE);
                    t.setRotation(r);
                } else {
                    t.setRotation(0);
                }
            }
        }

        // --- Flow Flow ---
        function triggerFlowCalc() {
            if (flowAnimationId) cancelAnimationFrame(flowAnimationId);

            // Reset visuals
            for (let row of grid) for (let t of row) t.setVisuals(0);

            // BFS from source
            let stack = [startNode];
            let visited = new Set();
            visited.add(startNode);

            // Visual State Tracking
            // We need to mark WHICH arms are lit.
            // Tile.connectedMask = bitmask of LIT connections
            for (let row of grid) for (let t of row) t.litMask = 0;

            startNode.litMask = startNode.getConnections(); // Source lights all its connections? No, source is "full".

            // Flow Propagation
            // If A connects to B, and A is Lit, B becomes Lit.
            // We want to visualize the PATH.

            // Multi-pass BFS for correct flow feeling?
            // Simple version:

            let active = [startNode];
            let nextActive = [];

            // Mark start node center as lit
            startNode.litMask |= 1; // Center

            function propagate() {
                let changed = false;
                // For each tile, check its neighbors.
                // If neighbor connects to me, and I am lit (at that port), then neighbor gets lit (at opposing port)
                // And if neighbor gets lit arm, it lights its center?

                // Let's do a simple recursive crawl from start.
                let q = [startNode];
                let seen = new Set([startNode]);

                // We need to track incoming flow directions to light up correct arms
                let flowMap = new Map(); // tile -> litMask
                flowMap.set(startNode, 1 | startNode.getConnections() << 1);
                // Note: setVisuals expects mask: Bit 0=Center, Bits 1..N=Arms

                let head = 0;
                while (head < q.length) {
                    let curr = q[head++];
                    let currMask = flowMap.get(curr);

                    // Get neighbors using topology
                    // We need x,y to get neighbors
                    let neighbors = GRID_LOGIC[GRID_TYPE].getNeighbors(curr.x, curr.y);
                    let currConns = curr.getConnections(); // 0..N-1 bitmask

                    for (let n of neighbors) {
                        // n has {x, y, dir, opp}
                        // Check if Current has connection in 'dir'

                        let myDir = n.dir;
                        let oppDir = n.opp;

                        if (NODE_SHAPE === 3) {
                            if (myDir % 2 !== 0) continue;
                            myDir /= 2;
                            oppDir /= 2;
                        }

                        if (currConns & (1 << myDir)) {
                            // Connected visually.
                            // Check neighbor tile
                            let nt = grid[n.y][n.x];
                            let ntConns = nt.getConnections();

                            if (ntConns & (1 << oppDir)) {
                                // Connection matches!
                                // Light up my arm
                                // Light up neighbor arm
                                // Light up neighbor center

                                // Update my mask (redundant if already calculated but good for clarity)
                                // currMask |= (1 << (myDir + 1));

                                let ntMask = flowMap.get(nt) || 0;
                                let newNtMask = ntMask | 1 | (1 << (oppDir + 1));

                                // Also light up ALL connected arms of neighbor if center is lit?
                                // "Fluid" fills the node. So yes.
                                // If center is lit, all connected arms light up? 
                                // Or does it flow through?
                                // Let's say it flows through. If center lit, all valid connections light up.

                                // If we just became lit (center), we blast to all our connections
                                let becameLit = (ntMask & 1) === 0 && (newNtMask & 1) === 1;

                                if ((ntMask & 1) === 0) {
                                    // First time lighting up center -> light up all valid arms
                                    for (let i = 0; i < NODE_SHAPE; i++) {
                                        if (ntConns & (1 << i)) newNtMask |= (1 << (i + 1));
                                    }
                                }

                                if (newNtMask !== ntMask) {
                                    flowMap.set(nt, newNtMask);
                                    if (!seen.has(nt)) {
                                        seen.add(nt);
                                        q.push(nt);
                                    }
                                }
                            }
                        }
                    }
                }

                // Apply visuals
                let litCount = 0;
                let totalTiles = GRID_W * GRID_H;

                flowMap.forEach((mask, t) => {
                    t.setVisuals(mask);
                    litCount++;
                });

                // Check Victory
                // All tiles lit? Or just Anchors? 
                // Usually "Stabilize Grid" means all tiles participating?
                // Let's simpler: If all EndNodes are lit.
                let allSinksLit = endNodes.every(t => flowMap.has(t));
                let percent = Math.floor((litCount / totalTiles) * 100);

                statusEl.innerText = `${percent}% Lit`;

                if (allSinksLit && endNodes.length > 0) {
                    victoryEl.classList.add('visible');
                    audio.playVictory();
                }
            }

            propagate();
        }

    </script>
</body>

</html>