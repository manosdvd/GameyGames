<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Wordle</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="../timeLimit.js"></script>
    <style>
        body {
            background-color: #121213;
            color: white;
            font-family: 'Clear Sans', 'Helvetica Neue', Arial, sans-serif;
            margin: 0;
            overflow: hidden;
            touch-action: manipulation;
        }

        .tile {
            display: inline-flex;
            justify-content: center;
            align-items: center;
            font-size: 2rem;
            line-height: 2rem;
            font-weight: bold;
            vertical-align: middle;
            box-sizing: border-box;
            color: #fff;
            text-transform: uppercase;
            user-select: none;
            border: 2px solid #3a3a3c;
        }

        .tile[data-state='empty'] {
            border: 2px solid #3a3a3c;
        }

        .tile[data-state='tbd'] {
            border: 2px solid #565758;
            color: #fff;
        }

        .tile[data-state='correct'] {
            background-color: #538d4e;
            border-color: #538d4e;
        }

        .tile[data-state='present'] {
            background-color: #b59f3b;
            border-color: #b59f3b;
        }

        .tile[data-state='absent'] {
            background-color: #3a3a3c;
            border-color: #3a3a3c;
        }

        .tile[data-animation='pop'] {
            animation: PopIn 100ms;
        }

        .tile[data-animation='flip'] {
            animation: Flip 500ms ease-in;
        }

        @keyframes PopIn {
            from {
                transform: scale(0.8);
                opacity: 0;
            }

            40% {
                transform: scale(1.1);
                opacity: 1;
            }
        }

        @keyframes Flip {
            0% {
                transform: rotateX(0);
                border-color: #565758;
            }

            50% {
                transform: rotateX(90deg);
                border-color: #565758;
            }

            100% {
                transform: rotateX(0);
            }
        }

        .shake {
            animation: Shake 600ms;
        }

        @keyframes Shake {

            10%,
            90% {
                transform: translateX(-1px);
            }

            20%,
            80% {
                transform: translateX(2px);
            }

            30%,
            50%,
            70% {
                transform: translateX(-4px);
            }

            40%,
            60% {
                transform: translateX(4px);
            }
        }
    </style>
</head>

<body>
    <div id="root"></div>
    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        const KEYBOARD_QWERTY = [
            'QWERTYUIOP'.split(''),
            'ASDFGHJKL'.split(''),
            ['ENTER', ...'ZXCVBNM'.split(''), 'BACK']
        ];

        const App = () => {
            const [dictionary, setDictionary] = useState(new Set());
            const [solution, setSolution] = useState('');
            const [guesses, setGuesses] = useState([]);
            const [currentGuess, setCurrentGuess] = useState('');
            const [gameStatus, setGameStatus] = useState('loading'); // loading, playing, won, lost
            const [shakeRow, setShakeRow] = useState(false);
            const [message, setMessage] = useState(null);
            const [stats, setStats] = useState({ played: 0, wins: 0, streak: 0 });

            useEffect(() => {
                // Load Stats
                const savedStats = localStorage.getItem('wordle_stats');
                if (savedStats) setStats(JSON.parse(savedStats));

                // Fetch Dictionary
                fetch('https://raw.githubusercontent.com/dwyl/english-words/master/words_alpha.txt')
                    .then(res => res.text())
                    .then(text => {
                        const words = text.split('\n')
                            .map(w => w.trim().toUpperCase())
                            .filter(w => w.length === 5);
                        const dict = new Set(words);
                        setDictionary(dict);
                        startNewGame(Array.from(words));
                    });
            }, []);

            const startNewGame = (wordsArray = null) => {
                const words = wordsArray || Array.from(dictionary);
                if (words.length === 0) return;
                const rand = words[Math.floor(Math.random() * words.length)];
                setSolution(rand);
                setGuesses([]);
                setCurrentGuess('');
                setGameStatus('playing');
                setMessage(null);
            };

            const handleKey = (key) => {
                if (gameStatus !== 'playing') return;

                if (key === 'BACK') {
                    setCurrentGuess(prev => prev.slice(0, -1));
                    return;
                }

                if (key === 'ENTER') {
                    if (currentGuess.length !== 5) {
                        showMessage("Not enough letters");
                        setShakeRow(true); setTimeout(() => setShakeRow(false), 600);
                        return;
                    }
                    if (!dictionary.has(currentGuess)) {
                        showMessage("Not in word list");
                        setShakeRow(true); setTimeout(() => setShakeRow(false), 600);
                        return;
                    }

                    const newGuesses = [...guesses, currentGuess];
                    setGuesses(newGuesses);
                    setCurrentGuess('');

                    if (currentGuess === solution) {
                        setGameStatus('won');
                        showMessage(getRandomCompliment(), 2000);
                        updateStats(true);
                    } else if (newGuesses.length >= 6) {
                        setGameStatus('lost');
                        showMessage(solution, -1); // Persist
                        updateStats(false);
                    }
                    return;
                }

                if (currentGuess.length < 5) {
                    setCurrentGuess(prev => prev + key);
                }
            };

            const updateStats = (won) => {
                setStats(prev => {
                    const newStats = {
                        played: prev.played + 1,
                        wins: won ? prev.wins + 1 : prev.wins,
                        streak: won ? prev.streak + 1 : 0
                    };
                    localStorage.setItem('wordle_stats', JSON.stringify(newStats));
                    return newStats;
                });
            };

            const showMessage = (msg, duration = 1000) => {
                setMessage(msg);
                if (duration > 0) setTimeout(() => setMessage(null), duration);
            };

            const getRandomCompliment = () => {
                const list = ['Genius', 'Magnificent', 'Impressive', 'Splendid', 'Great', 'Phew'];
                return list[guesses.length] || 'Good';
            };

            // Keyboard Listeners
            useEffect(() => {
                const handleKeyDown = (e) => {
                    if (e.ctrlKey || e.metaKey || e.altKey) return;
                    const key = e.key.toUpperCase();
                    if (key === 'ENTER') handleKey('ENTER');
                    else if (key === 'BACKSPACE') handleKey('BACK');
                    else if (/^[A-Z]$/.test(key)) handleKey(key);
                };
                window.addEventListener('keydown', handleKeyDown);
                return () => window.removeEventListener('keydown', handleKeyDown);
            }, [currentGuess, gameStatus, guesses]);

            // Helper for colors
            const getKeyStatus = (key) => {
                let status = 'unused';
                // Priority: Correct > Present > Absent
                for (let g of guesses) {
                    for (let i = 0; i < 5; i++) {
                        if (g[i] === key) {
                            if (solution[i] === key) return 'correct';
                            if (solution.includes(key)) status = 'present';
                            else if (status === 'unused') status = 'absent';
                        }
                    }
                }
                return status;
            };

            const getTileStatus = (rowIndex, colIndex) => {
                // If this is a completed guess
                if (rowIndex < guesses.length) {
                    const letter = guesses[rowIndex][colIndex];
                    if (letter === solution[colIndex]) return 'correct';
                    if (solution.includes(letter)) {
                        // Complex logic for duplicates... skipping for simple MVP or correct?
                        // Standard wordle checks count of letters
                        // A simple "includes" is often 'wrong' if the letter is used elsewhere correctly.
                        // Let's implement proper count check.

                        const guess = guesses[rowIndex];
                        const sArr = solution.split('');
                        const gArr = guess.split('');

                        // First pass: mark correct
                        const marked = Array(5).fill(false);
                        const taken = Array(5).fill(false); // slots in solution taken

                        // Mark exact matches
                        for (let i = 0; i < 5; i++) {
                            if (sArr[i] === gArr[i]) {
                                marked[i] = true;
                                taken[i] = true;
                            }
                        }

                        // Just check this tile
                        if (marked[colIndex]) return 'correct'; // Should be caught above

                        // Now check if this letter exists elsewhere available
                        let matchCount = 0;
                        // Count how many of this letter in solution are NOT taken by exact matches
                        let available = 0;
                        for (let i = 0; i < 5; i++) {
                            if (sArr[i] === letter && !taken[i]) available++;
                        }

                        // Count how many of this letter appear in this guess before or at this index, that are NOT exact matches
                        let myIndexAmongMisses = 0;
                        for (let i = 0; i <= colIndex; i++) {
                            if (gArr[i] === letter && sArr[i] !== letter) {
                                myIndexAmongMisses++;
                            }
                        }

                        if (myIndexAmongMisses <= available) return 'present';
                        return 'absent';
                    }
                    return 'absent';
                }
                if (rowIndex === guesses.length) {
                    if (colIndex < currentGuess.length) return 'tbd';
                    return 'empty';
                }
                return 'empty';
            };

            return (
                <div className="flex flex-col h-[100dvh] w-full max-w-md mx-auto relative bg-[#121213] overflow-hidden">
                    {/* Header */}
                    <div className="flex-none flex items-center justify-between px-4 py-2 border-b border-[#3a3a3c] h-12">
                        <a href="../index.html" className="text-gray-400 hover:text-white">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M19 12H5M12 19l-7-7 7-7" /></svg>
                        </a>
                        <h1 className="text-2xl md:text-3xl font-extrabold tracking-wider">WORDLE</h1>
                        <div className="flex gap-4">
                            <button onClick={() => startNewGame()} className="text-gray-400 hover:text-white">
                                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="23 4 23 10 17 10"></polyline><path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"></path></svg>
                            </button>
                        </div>
                    </div>

                    {/* Grid Container */}
                    <div className="flex-1 flex justify-center items-center p-2 min-h-0">
                        {/* Grid Aspect Ratio 5/6 (5 cols, 6 rows) */}
                        <div className="grid grid-rows-6 gap-[5px] w-auto h-full max-h-[420px] aspect-[5/6]">
                            {Array.from({ length: 6 }).map((_, r) => (
                                <div key={r} className={`grid grid-cols-5 gap-[5px] ${r === guesses.length && shakeRow ? 'shake' : ''}`}>
                                    {Array.from({ length: 5 }).map((_, c) => {
                                        let char = '';
                                        let status = 'empty';

                                        if (r < guesses.length) {
                                            char = guesses[r][c];
                                            status = getTileStatus(r, c);
                                        } else if (r === guesses.length) {
                                            char = currentGuess[c] || '';
                                            status = char ? 'tbd' : 'empty';
                                        }

                                        // Animation delay
                                        const animDelay = (r < guesses.length) ? `${c * 100}ms` : '0ms';

                                        return (
                                            <div
                                                key={c}
                                                className="tile w-full h-full text-2xl md:text-3xl font-bold"
                                                data-state={status}
                                                style={{ animationDelay: animDelay }}
                                                data-animation={char && r === guesses.length ? 'pop' : (r < guesses.length ? 'flip' : '')}
                                            >
                                                {char}
                                            </div>
                                        );
                                    })}
                                </div>
                            ))}
                        </div>
                    </div>

                    {/* Toast Message */}
                    {message && (
                        <div className="absolute top-16 left-1/2 transform -translate-x-1/2 bg-white text-black px-4 py-2 rounded font-bold shadow-lg z-50 whitespace-nowrap">
                            {message}
                        </div>
                    )}

                    {/* Keyboard */}
                    <div className="flex-none px-2 pb-4 md:pb-8 w-full">
                        {KEYBOARD_QWERTY.map((row, i) => (
                            <div key={i} className="flex justify-center gap-[6px] mb-[8px] w-full">
                                {row.map(key => {
                                    let bg = '#818384';
                                    const status = getKeyStatus(key);
                                    if (status === 'correct') bg = '#538d4e';
                                    else if (status === 'present') bg = '#b59f3b';
                                    else if (status === 'absent') bg = '#3a3a3c';

                                    const isSpecial = key.length > 1;

                                    return (
                                        <button
                                            key={key}
                                            onClick={() => handleKey(key)}
                                            className={`
                                                flex items-center justify-center rounded font-bold text-xs md:text-sm cursor-pointer select-none
                                                ${isSpecial ? 'px-2 md:px-4' : 'flex-1'}
                                                h-[48px] md:h-[58px]
                                            `}
                                            style={{ backgroundColor: bg, minWidth: isSpecial ? 'auto' : '30px' }}
                                        >
                                            {key === 'BACK' ? (
                                                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 4H8l-7 8 7 8h13a2 2 0 0 0 2-2V6a2 2 0 0 0-2-2z"></path><line x1="18" y1="9" x2="12" y2="15"></line><line x1="12" y1="9" x2="18" y2="15"></line></svg>
                                            ) : key}
                                        </button>
                                    );
                                })}
                            </div>
                        ))}
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>

</html>