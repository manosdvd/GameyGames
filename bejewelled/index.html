<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Gem Rush</title>
    <script src="../timeLimit.js"></script>
    <style>
        :root {
            --bg-color: #0d0d15;
            --grid-bg: #1a1a24;
            --accent: #ff00de;
            --text: #fff;
            --gem-size: 50px;
        }

        * {
            box-sizing: border-box;
            touch-action: none;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            margin: 0;
            background: var(--bg-color);
            color: var(--text);
            font-family: 'Segoe UI', system-ui, sans-serif;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        /* --- Background --- */
        #bg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            background: radial-gradient(circle at center, #222233 0%, #050508 100%);
        }

        /* --- UI --- */
        #ui-layer {
            position: absolute;
            top: 20px;
            width: 100%;
            display: flex;
            justify-content: space-between;
            padding: 0 20px;
            pointer-events: none;
            z-index: 10;
        }

        .score-box {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            padding: 10px 20px;
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            text-align: center;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            pointer-events: auto;
        }

        .label {
            font-size: 0.8rem;
            text-transform: uppercase;
            color: #aaa;
            letter-spacing: 1px;
        }

        .value {
            font-size: 1.5rem;
            font-weight: 800;
            color: #fff;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        }

        #back-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            padding: 10px 15px;
            border-radius: 50%;
            cursor: pointer;
            font-weight: bold;
            pointer-events: auto;
            transition: all 0.2s;
        }

        #back-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.1);
        }

        /* --- Game Board --- */
        #game-container {
            position: relative;
            width: 90vw;
            max-width: 500px;
            aspect-ratio: 1/1;
            background: var(--grid-bg);
            border-radius: 12px;
            border: 4px solid #333;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            padding: 4px;
            gap: 2px;
            touch-action: none;
        }

        /* Shake effect container */
        .shaker {
            animation-duration: 0.5s;
            animation-fill-mode: both;
        }

        @keyframes shake {
            0% {
                transform: translate(0, 0);
            }

            10%,
            90% {
                transform: translate(-3px, -1px);
            }

            20%,
            80% {
                transform: translate(3px, 2px);
            }

            30%,
            50%,
            70% {
                transform: translate(-5px, 2px);
            }

            40%,
            60% {
                transform: translate(5px, -2px);
            }

            100% {
                transform: translate(0, 0);
            }
        }

        .cell {
            position: relative;
            width: 100%;
            height: 100%;
            border-radius: 4px;
            background: rgba(0, 0, 0, 0.2);
        }

        .gem {
            position: absolute;
            width: 90%;
            height: 90%;
            left: 5%;
            top: 5%;
            border-radius: 15%;
            transition: transform 0.2s, top 0.2s cubic-bezier(0.5, 0, 0.5, 1);
            z-index: 2;
            cursor: pointer;
            /* Neumorphic/Glassmorphic look */
            box-shadow: inset 0 0 10px rgba(255, 255, 255, 0.4), 0 4px 6px rgba(0, 0, 0, 0.3);
        }

        .gem.selected {
            filter: brightness(1.5);
            transform: scale(1.1);
            box-shadow: 0 0 15px white;
            z-index: 10;
        }

        .gem.match {
            animation: zoomOut 0.3s forwards;
        }

        @keyframes zoomOut {
            to {
                transform: scale(0);
                opacity: 0;
            }
        }

        /* Gem Colors */
        .gem-0 {
            background: radial-gradient(circle at 30% 30%, #ff4d4d, #990000);
        }

        /* Red */
        .gem-1 {
            background: radial-gradient(circle at 30% 30%, #4dff4d, #009900);
        }

        /* Green */
        .gem-2 {
            background: radial-gradient(circle at 30% 30%, #4d4dff, #000099);
        }

        /* Blue */
        .gem-3 {
            background: radial-gradient(circle at 30% 30%, #ffff4d, #999900);
        }

        /* Yellow */
        .gem-4 {
            background: radial-gradient(circle at 30% 30%, #ff4dff, #990099);
            border-radius: 50%;
        }

        /* Purple Circle */
        .gem-5 {
            background: radial-gradient(circle at 30% 30%, #ff9e4d, #994c00);
            clip-path: polygon(50% 0%, 100% 50%, 50% 100%, 0% 50%);
            border-radius: 0;
        }

        /* Orange Diamond */
        .gem-6 {
            background: radial-gradient(circle at 30% 30%, #ffffff, #888888);
            clip-path: polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%);
            border-radius: 0;
        }

        /* White Hex */

        /* Canvas for particles */
        #fx-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 20;
        }

        /* Overlay */
        #start-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
            backdrop-filter: blur(5px);
        }

        .btn-large {
            background: linear-gradient(45deg, #ff00de, #00ffaa);
            border: none;
            padding: 15px 40px;
            font-size: 1.5rem;
            font-weight: bold;
            color: white;
            border-radius: 50px;
            cursor: pointer;
            box-shadow: 0 0 20px rgba(255, 0, 222, 0.4);
            transition: transform 0.2s;
            text-transform: uppercase;
        }

        .btn-large:hover {
            transform: scale(1.05);
        }
    </style>
</head>

<body>
    <div id="bg"></div>

    <div id="ui-layer">
        <button id="back-btn" onclick="window.location.href='../index.html'"> &lt; </button>
        <div class="score-box">
            <div class="label">Score</div>
            <div class="value" id="score-display">0</div>
        </div>
    </div>

    <div id="start-overlay">
        <h1 style="font-size: 4rem; margin-bottom: 2rem; text-shadow: 0 0 30px #ff00de;">GEM RUSH</h1>
        <button class="btn-large" onclick="startGame()">PLAY</button>
    </div>

    <div class="shaker" id="shaker">
        <div id="game-container"></div>
    </div>

    <canvas id="fx-canvas"></canvas>

    <script>
        // --- Audio System ---
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        const audioCtx = new AudioContext();

        function playSound(type) {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);

            const now = audioCtx.currentTime;

            if (type === 'swap') {
                osc.type = 'sine';
                osc.frequency.setValueAtTime(300, now);
                osc.frequency.exponentialRampToValueAtTime(600, now + 0.1);
                gain.gain.setValueAtTime(0.1, now);
                gain.gain.linearRampToValueAtTime(0, now + 0.1);
                osc.start(now);
                osc.stop(now + 0.1);
            } else if (type === 'match') {
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(400, now);
                osc.frequency.exponentialRampToValueAtTime(800, now + 0.1);
                // Chord
                const osc2 = audioCtx.createOscillator();
                osc2.type = 'triangle';
                osc2.frequency.setValueAtTime(600, now);
                osc2.frequency.exponentialRampToValueAtTime(1200, now + 0.15);
                osc2.connect(gain);
                osc2.start(now);
                osc2.stop(now + 0.2);

                gain.gain.setValueAtTime(0.2, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
                osc.start(now);
                osc.stop(now + 0.3);
            } else if (type === 'bad') {
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(150, now);
                osc.frequency.linearRampToValueAtTime(100, now + 0.2);
                gain.gain.setValueAtTime(0.1, now);
                gain.gain.linearRampToValueAtTime(0, now + 0.2);
                osc.start(now);
                osc.stop(now + 0.2);
            }
        }

        // --- Game Logic ---
        const GRID_SIZE = 8;
        const NUM_GEMS = 7;
        const container = document.getElementById('game-container');
        const scoreDisplay = document.getElementById('score-display');
        const shaker = document.getElementById('shaker');

        let grid = []; // 2D array storing gem types (0-6) or -1 (empty)
        let visualGrid = []; // 2D array storing DOM elements
        let score = 0;
        let selected = null; // {r, c}
        let isProcessing = false;

        function startGame() {
            document.getElementById('start-overlay').style.display = 'none';
            if (document.documentElement.requestFullscreen) document.documentElement.requestFullscreen().catch(e => { });
            initGrid();
        }

        function initGrid() {
            container.innerHTML = '';
            grid = [];
            visualGrid = [];
            score = 0;
            updateScore(0);

            for (let r = 0; r < GRID_SIZE; r++) {
                let row = [];
                let vRow = [];
                for (let c = 0; c < GRID_SIZE; c++) {
                    let type;
                    // Prevent initial matches
                    do {
                        type = Math.floor(Math.random() * NUM_GEMS);
                    } while (
                        (c >= 2 && row[c - 1] === type && row[c - 2] === type) ||
                        (r >= 2 && grid[r - 1][c] === type && grid[r - 2][c] === type)
                    );

                    row.push(type);

                    // Create Cell (Background)
                    let cell = document.createElement('div');
                    cell.className = 'cell';
                    container.appendChild(cell);

                    // Create Gem
                    let gem = createGemDOM(type, r, c);
                    cell.appendChild(gem);
                    vRow.push(gem);

                    // Interaction
                    gem.onmousedown = (e) => handleInput(r, c);
                    gem.ontouchstart = (e) => { e.preventDefault(); handleInput(r, c); };
                }
                grid.push(row);
                visualGrid.push(vRow);
            }
        }

        function createGemDOM(type, r, c) {
            let el = document.createElement('div');
            el.className = `gem gem-${type}`;
            el.dataset.r = r;
            el.dataset.c = c;
            return el;
        }

        function handleInput(r, c) {
            if (isProcessing) return;

            if (!selected) {
                // Select
                selected = { r, c };
                visualGrid[r][c].classList.add('selected');
                playSound('swap');
            } else {
                // Check adjacency
                let dr = Math.abs(selected.r - r);
                let dc = Math.abs(selected.c - c);

                if (selected.r === r && selected.c === c) {
                    // Deselect
                    visualGrid[selected.r][selected.c].classList.remove('selected');
                    selected = null;
                } else if (dr + dc === 1) {
                    // Swap
                    visualGrid[selected.r][selected.c].classList.remove('selected');
                    attemptSwap(selected, { r, c });
                    selected = null;
                } else {
                    // Invalid, just select new
                    visualGrid[selected.r][selected.c].classList.remove('selected');
                    selected = { r, c };
                    visualGrid[r][c].classList.add('selected');
                    playSound('swap');
                }
            }
        }

        async function attemptSwap(p1, p2) {
            isProcessing = true;

            // Visual swap
            await swapVisuals(p1, p2);

            // Logic swap
            let t = grid[p1.r][p1.c];
            grid[p1.r][p1.c] = grid[p2.r][p2.c];
            grid[p2.r][p2.c] = t;

            // Check Match
            let matches = findMatches();
            if (matches.length > 0) {
                await processMatches(matches);
            } else {
                // Swap back
                playSound('bad');
                await swapVisuals(p1, p2);
                // Revert Logic -- Error here logic swap again reverts it
                t = grid[p1.r][p1.c];
                grid[p1.r][p1.c] = grid[p2.r][p2.c];
                grid[p2.r][p2.c] = t;
                isProcessing = false;
            }
        }

        function swapVisuals(p1, p2) {
            return new Promise(resolve => {
                let g1 = visualGrid[p1.r][p1.c];
                let g2 = visualGrid[p2.r][p2.c];

                // We physically move them in DOM or just animate?
                // Easier to swap DOM parent or swap class?
                // Class swap is cleaner but we need to keep references consistent.

                // Let's swap the DOM elements in the array and re-parent them
                // Get cells
                let c1 = container.children[p1.r * GRID_SIZE + p1.c];
                let c2 = container.children[p2.r * GRID_SIZE + p2.c];

                // Animate
                // Calculate relative positions
                let xDiff = (p2.c - p1.c) * 100;
                let yDiff = (p2.r - p1.r) * 100;

                g1.style.transform = `translate(${xDiff}%, ${yDiff}%)`;
                g2.style.transform = `translate(${-xDiff}%, ${-yDiff}%)`;

                setTimeout(() => {
                    // Reset transform
                    g1.style.transform = '';
                    g2.style.transform = '';

                    // Actually swap DOM parents
                    c1.appendChild(g2);
                    c2.appendChild(g1);

                    // Swap Input Handlers (closure captures r/c) - Re-binding needed?
                    // Yes, or we just rely on updating the visualGrid array and re-binding events?
                    // Let's re-bind based on new position
                    updateHandlers();

                    // Swap array
                    visualGrid[p1.r][p1.c] = g2;
                    visualGrid[p2.r][p2.c] = g1;

                    resolve();
                }, 200);
            });
        }

        function updateHandlers() {
            for (let r = 0; r < GRID_SIZE; r++) {
                for (let c = 0; c < GRID_SIZE; c++) {
                    let g = visualGrid[r][c];
                    g.onmousedown = (e) => handleInput(r, c);
                    g.ontouchstart = (e) => { e.preventDefault(); handleInput(r, c); };
                }
            }
        }

        function findMatches() {
            let matched = new Set();

            // Horizontal
            for (let r = 0; r < GRID_SIZE; r++) {
                for (let c = 0; c < GRID_SIZE - 2; c++) {
                    let type = grid[r][c];
                    if (type === -1) continue;
                    let matchLen = 1;
                    while (c + matchLen < GRID_SIZE && grid[r][c + matchLen] === type) matchLen++;
                    if (matchLen >= 3) {
                        for (let i = 0; i < matchLen; i++) matched.add(`${r},${c + i}`);
                        c += matchLen - 1;
                    }
                }
            }

            // Vertical
            for (let c = 0; c < GRID_SIZE; c++) {
                for (let r = 0; r < GRID_SIZE - 2; r++) {
                    let type = grid[r][c];
                    if (type === -1) continue;
                    let matchLen = 1;
                    while (r + matchLen < GRID_SIZE && grid[r + matchLen][c] === type) matchLen++;
                    if (matchLen >= 3) {
                        for (let i = 0; i < matchLen; i++) matched.add(`${r + i},${c}`);
                        r += matchLen - 1;
                    }
                }
            }

            return Array.from(matched).map(s => {
                let [r, c] = s.split(',').map(Number);
                return { r, c };
            });
        }

        async function processMatches(matches) {
            // Remove
            playSound('match');
            shakeScreen();

            // Particles
            matches.forEach(m => {
                let rect = visualGrid[m.r][m.c].getBoundingClientRect();
                spawnParticles(rect.left + rect.width / 2, rect.top + rect.height / 2, grid[m.r][m.c]);
            });

            // Updating State
            matches.forEach(m => {
                grid[m.r][m.c] = -1;
                visualGrid[m.r][m.c].classList.add('match');
            });

            score += matches.length * 10;
            updateScore(score);

            await sleep(300);

            // Destroy DOMs
            matches.forEach(m => {
                let el = visualGrid[m.r][m.c];
                el.remove(); // Remove from DOM
                visualGrid[m.r][m.c] = null;
            });

            // Gravity
            await applyGravity();

            // Check Cascade
            let newMatches = findMatches();
            if (newMatches.length > 0) {
                await sleep(200);
                await processMatches(newMatches);
            } else {
                isProcessing = false;
            }
        }

        async function applyGravity() {
            // Move items down
            let moves = false;

            // From bottom up (col by col)
            for (let c = 0; c < GRID_SIZE; c++) {
                let writeRow = GRID_SIZE - 1;
                for (let r = GRID_SIZE - 1; r >= 0; r--) {
                    if (grid[r][c] !== -1) {
                        if (writeRow !== r) {
                            // Move logic
                            grid[writeRow][c] = grid[r][c];
                            grid[r][c] = -1;

                            // Move Visually
                            let g = visualGrid[r][c];
                            visualGrid[writeRow][c] = g;
                            visualGrid[r][c] = null;

                            // Re-parent to new cell
                            let cell = container.children[writeRow * GRID_SIZE + c];
                            cell.appendChild(g); // Instant re-parent

                            // Animate Fall?
                            // Since we instantly re-parented, let's fake fall via CSS
                            // Actually, simple is ok for now. 
                            // To animate: set translateY negative (from old pos) and transition to 0.
                            // Currently simplest: just update handlers
                            moves = true;
                        }
                        writeRow--;
                    }
                }

                // Fill top with new
                for (let r = writeRow; r >= 0; r--) {
                    let type = Math.floor(Math.random() * NUM_GEMS);
                    grid[r][c] = type;
                    let cell = container.children[r * GRID_SIZE + c];
                    let g = createGemDOM(type, r, c);

                    // Fall in animation
                    g.style.top = '-100%';
                    cell.appendChild(g);
                    visualGrid[r][c] = g;

                    // Trigger reflow
                    g.offsetHeight;
                    g.style.top = '5%';
                    moves = true;
                }
            }

            updateHandlers();
            if (moves) await sleep(250);
        }

        function updateScore(s) {
            scoreDisplay.innerText = s;
        }

        function shakeScreen() {
            shaker.style.animation = 'none';
            shaker.offsetHeight; /* trigger reflow */
            shaker.style.animation = 'shake 0.5s';
        }

        const sleep = ms => new Promise(r => setTimeout(r, ms));

        // --- Particles ---
        const cvs = document.getElementById('fx-canvas');
        const ctx = cvs.getContext('2d');
        let particles = [];

        function resize() {
            cvs.width = window.innerWidth;
            cvs.height = window.innerHeight;
        }
        window.onresize = resize;
        resize();

        function spawnParticles(x, y, type) {
            let color = getGemColor(type);
            for (let i = 0; i < 10; i++) {
                particles.push({
                    x, y,
                    vx: (Math.random() - 0.5) * 10,
                    vy: (Math.random() - 0.5) * 10,
                    life: 1,
                    color: color,
                    size: Math.random() * 5 + 2
                });
            }
        }

        function getGemColor(t) {
            const cols = ['#ff0000', '#00ff00', '#0000ff', '#ffff00', '#ff00ff', '#ffaa00', '#ffffff'];
            return cols[t] || '#fff';
        }

        function loop() {
            ctx.clearRect(0, 0, cvs.width, cvs.height);
            for (let i = particles.length - 1; i >= 0; i--) {
                let p = particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.vy += 0.5; // Gravity
                p.life -= 0.02;
                p.size *= 0.95;

                ctx.fillStyle = p.color;
                ctx.globalAlpha = p.life;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();

                if (p.life <= 0) particles.splice(i, 1);
            }
            requestAnimationFrame(loop);
        }
        loop();

    </script>
</body>

</html>