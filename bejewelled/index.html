<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Gem Rush</title>
    <script src="../timeLimit.js"></script>
    <script src="../shared/settings.js"></script>
    <link rel="stylesheet" href="../shared/theme.css">
    <style>
        :root {
            --bg-color: var(--cyber-bg);
            --grid-bg: var(--cyber-surface);
            --accent: var(--cyber-magenta);
            --text: var(--cyber-text);
            --gem-size: 50px;
        }

        * {
            box-sizing: border-box;
            touch-action: none;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            margin: 0;
            background: var(--bg-color);
            color: var(--text);
            font-family: 'Segoe UI', system-ui, sans-serif;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100dvh;
            width: 100vw;
        }

        /* --- Background --- */
        #bg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            background: radial-gradient(circle at center, #222233 0%, #050508 100%);
        }

        /* --- UI --- */
        #ui-layer {
            position: absolute;
            top: 20px;
            width: 100%;
            display: flex;
            justify-content: space-between;
            padding: 0 20px;
            pointer-events: none;
            z-index: 10;
        }

        .score-box {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            padding: 8px 16px;
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            text-align: center;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            pointer-events: auto;
        }

        .label {
            font-size: 0.7rem;
            text-transform: uppercase;
            color: #aaa;
            letter-spacing: 1px;
        }

        .value {
            font-size: 1.2rem;
            font-weight: 800;
            color: #fff;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        }

        #back-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            padding: 10px 15px;
            border-radius: 50%;
            cursor: pointer;
            font-weight: bold;
            pointer-events: auto;
            transition: all 0.2s;
        }

        #back-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.1);
        }

        /* --- Game Board --- */
        #game-wrapper {
            width: 100%;
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 10px;
            overflow: hidden;
        }

        #game-container {
            position: relative;
            background: var(--grid-bg);
            border-radius: 12px;
            border: 4px solid #333;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            width: min(95vw, 90dvh);
            height: min(95vw, 90dvh);
            display: block;
        }

        /* Gems */
        .gem {
            position: absolute;
            width: 12.5%;
            height: 12.5%;
            top: 0;
            left: 0;
            padding: 2%;
            z-index: 2;
            cursor: pointer;
            /* No default transition to allow JS control */
        }

        .gem-inner {
            width: 100%;
            height: 100%;
            border-radius: 15%;
            box-shadow: inset 0 0 10px rgba(255, 255, 255, 0.4), 0 3px 5px rgba(0, 0, 0, 0.4);
            transition: filter 0.1s, transform 0.1s;
        }

        .gem.selected .gem-inner {
            filter: brightness(1.5);
            transform: scale(1.15);
            box-shadow: 0 0 15px white;
            z-index: 10;
        }

        .gem.match .gem-inner {
            animation: popOut 0.3s forwards;
        }

        @keyframes popOut {
            0% {
                transform: scale(1);
                opacity: 1;
            }

            50% {
                transform: scale(1.3);
                opacity: 0.8;
            }

            100% {
                transform: scale(0);
                opacity: 0;
            }
        }

        /* Shapes */
        .g0 .gem-inner {
            background: radial-gradient(circle at 30% 30%, #ff4d4d, #990000);
        }

        .g1 .gem-inner {
            background: radial-gradient(circle at 30% 30%, #4dff4d, #009900);
        }

        .g2 .gem-inner {
            background: radial-gradient(circle at 30% 30%, #4d4dff, #000099);
        }

        .g3 .gem-inner {
            background: radial-gradient(circle at 30% 30%, #ffff4d, #999900);
        }

        .g4 .gem-inner {
            background: radial-gradient(circle at 30% 30%, #ff4dff, #990099);
            border-radius: 50%;
        }

        .g5 .gem-inner {
            background: radial-gradient(circle at 30% 30%, #ff9e4d, #994c00);
            clip-path: polygon(50% 0%, 100% 50%, 50% 100%, 0% 50%);
            border-radius: 0;
        }

        .g6 .gem-inner {
            background: radial-gradient(circle at 30% 30%, #ffffff, #888888);
            clip-path: polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%);
            border-radius: 0;
        }

        /* FX */
        #fx-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 20;
        }

        .shake-anim {
            animation: shake 0.4s cubic-bezier(.36, .07, .19, .97) both;
        }

        @keyframes shake {

            10%,
            90% {
                transform: translate3d(-1px, 0, 0);
            }

            20%,
            80% {
                transform: translate3d(2px, 0, 0);
            }

            30%,
            50%,
            70% {
                transform: translate3d(-4px, 0, 0);
            }

            40%,
            60% {
                transform: translate3d(4px, 0, 0);
            }
        }

        /* Overlay */
        #overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
            backdrop-filter: blur(8px);
        }

        .btn-play {
            background: linear-gradient(135deg, #ff00de, #00ffaa);
            border: none;
            padding: 20px 60px;
            font-size: 2rem;
            font-weight: 900;
            color: white;
            border-radius: 60px;
            cursor: pointer;
            box-shadow: 0 0 30px rgba(255, 0, 222, 0.5);
            text-transform: uppercase;
            letter-spacing: 2px;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .btn-play:active {
            transform: scale(0.95);
        }
    </style>
</head>

<body>
    <div id="bg"></div>
    <div id="ui-layer">
        <button id="back-btn" onclick="window.location.href='../index.html'"> &lt; </button>
        <div class="score-box">
            <div class="label">Score</div>
            <div class="value" id="score">0</div>
        </div>
    </div>
    <div id="game-wrapper" class="shaker">
        <div id="game-container"></div>
    </div>
    <div id="overlay">
        <div
            style="font-size: 4rem; font-weight: 900; color: #fff; text-shadow: 0 0 20px #ff00de; margin-bottom: 30px;">
            GEM RUSH</div>
        <button class="btn-play" onclick="initGame()">PLAY</button>
    </div>
    <canvas id="fx-canvas"></canvas>

    <script>
        const container = document.getElementById('game-container');
        const scoreEl = document.getElementById('score');
        const fxCanvas = document.getElementById('fx-canvas');
        const ctx = fxCanvas.getContext('2d');

        // --- Conf ---
        const ROWS = 8, COLS = 8, GEM_TYPES = 7;

        // --- State ---
        let grid = []; // Logical: { type, id }
        let gems = new Map(); // ID -> DOM Element
        let nextId = 1;
        let score = 0;
        let state = 'IDLE';
        let selected = null;
        let touchStart = null;

        // --- Init ---
        function resize() { fxCanvas.width = window.innerWidth; fxCanvas.height = window.innerHeight; }
        window.onresize = resize; resize();
        function rnd(n) { return Math.floor(Math.random() * n); }

        function initGame() {
            document.getElementById('overlay').style.display = 'none';
            if (document.documentElement.requestFullscreen) document.documentElement.requestFullscreen().catch(() => { });
            container.innerHTML = '';
            grid = []; score = 0; updateScore(0);
            for (let y = 0; y < ROWS; y++) {
                let row = [];
                for (let x = 0; x < COLS; x++) {
                    let type;
                    do { type = rnd(GEM_TYPES); } while (
                        (x >= 2 && row[x - 1].type === type && row[x - 2].type === type) ||
                        (y >= 2 && grid[y - 1][x].type === type && grid[y - 2][x].type === type)
                    );
                    let id = nextId++;
                    let g = createGem(id, type, x, y);
                    gems.set(id, g);
                    container.appendChild(g);
                    row.push({ type, id });
                }
                grid.push(row);
            }
            state = 'IDLE';
        }

        function createGem(id, type, x, y) {
            let d = document.createElement('div');
            d.className = `gem g${type}`;
            d.innerHTML = `<div class="gem-inner"></div>`;
            d.style.transform = `translate(${x * 100}%, ${y * 100}%)`;
            d.dataset.id = id;
            d.onmousedown = (e) => handleInputStart(x, y, e.clientX, e.clientY);
            d.ontouchstart = (e) => { e.preventDefault(); handleInputStart(x, y, e.touches[0].clientX, e.touches[0].clientY); };
            return d;
        }

        // --- Input ---
        function handleInputStart(x, y, cx, cy) {
            if (state !== 'IDLE') return;
            touchStart = { x, y, cx, cy };
            document.onmousemove = handleInputMove;
            document.onmouseup = handleInputEnd;
            document.ontouchmove = (e) => handleInputMove(e.touches[0]);
            document.ontouchend = handleInputEnd;
        }
        function handleInputMove(e) { }
        function handleInputEnd(e) {
            if (!touchStart) return;
            let cx, cy;
            if (e.type === 'mouseup') { cx = e.clientX; cy = e.clientY; }
            else if (e.changedTouches) { cx = e.changedTouches[0].clientX; cy = e.changedTouches[0].clientY; }
            else { cx = touchStart.cx; cy = touchStart.cy; }

            let dx = cx - touchStart.cx, dy = cy - touchStart.cy;
            let tx = touchStart.x, ty = touchStart.y;

            document.onmousemove = null; document.onmouseup = null;
            document.ontouchmove = null; document.ontouchend = null;

            if (Math.sqrt(dx * dx + dy * dy) < 20) handleClick(tx, ty);
            else {
                if (Math.abs(dx) > Math.abs(dy)) dx > 0 ? trySwap(tx, ty, tx + 1, ty) : trySwap(tx, ty, tx - 1, ty);
                else dy > 0 ? trySwap(tx, ty, tx, ty + 1) : trySwap(tx, ty, tx, ty - 1);
                if (selected) { gems.get(grid[selected.y][selected.x].id).classList.remove('selected'); selected = null; }
            }
            touchStart = null;
        }

        function handleClick(x, y) {
            if (selected) {
                let d = Math.abs(selected.x - x) + Math.abs(selected.y - y);
                if (d === 1) {
                    let prev = selected;
                    gems.get(grid[selected.y][selected.x].id).classList.remove('selected');
                    selected = null;
                    trySwap(prev.x, prev.y, x, y);
                } else {
                    gems.get(grid[selected.y][selected.x].id).classList.remove('selected');
                    if (selected.x === x && selected.y === y) selected = null;
                    else { selected = { x, y }; gems.get(grid[y][x].id).classList.add('selected'); playSound('select'); }
                }
            } else {
                selected = { x, y }; gems.get(grid[y][x].id).classList.add('selected'); playSound('select');
            }
        }

        async function trySwap(x1, y1, x2, y2) {
            if (x2 < 0 || x2 >= COLS || y2 < 0 || y2 >= ROWS) return;
            state = 'ANIMATING';

            let id1 = grid[y1][x1].id;
            let id2 = grid[y2][x2].id;

            // Simultaneous crisp swap
            await animateSwap(id1, x1, y1, id2, x2, y2);

            let temp = grid[y1][x1]; grid[y1][x1] = grid[y2][x2]; grid[y2][x2] = temp;
            updateDataset();

            let matches = findMatches();
            if (matches.length > 0) {
                playSound('match');
                await resolveMatches(matches);
            } else {
                playSound('bad');
                await animateSwap(id1, x2, y2, id2, x1, y1); // Swap back
                temp = grid[y1][x1]; grid[y1][x1] = grid[y2][x2]; grid[y2][x2] = temp;
                updateDataset();
                state = 'IDLE';
            }
        }

        function animateSwap(id1, x1, y1, id2, x2, y2) {
            return new Promise(resolve => {
                let g1 = gems.get(id1);
                let g2 = gems.get(id2);

                // Set CSS transition
                g1.style.transition = 'transform 0.25s cubic-bezier(0.2, 1.0, 0.4, 1.0)';
                g2.style.transition = 'transform 0.25s cubic-bezier(0.2, 1.0, 0.4, 1.0)';

                // Force Reflow
                g1.offsetHeight;

                // Move
                g1.style.transform = `translate(${x2 * 100}%, ${y2 * 100}%)`;
                g2.style.transform = `translate(${x1 * 100}%, ${y1 * 100}%)`;

                setTimeout(resolve, 250);
            });
        }

        function updateDataset() {
            for (let y = 0; y < ROWS; y++) {
                for (let x = 0; x < COLS; x++) {
                    let g = gems.get(grid[y][x].id);
                    if (g) {
                        g.onmousedown = (e) => handleInputStart(x, y, e.clientX, e.clientY);
                        g.ontouchstart = (e) => { e.preventDefault(); handleInputStart(x, y, e.touches[0].clientX, e.touches[0].clientY); };
                    }
                }
            }
        }

        function findMatches() {
            let set = new Set();
            for (let y = 0; y < ROWS; y++) {
                for (let x = 0; x < COLS - 2; x++) {
                    let t = grid[y][x].type; if (t === -1) continue;
                    let l = 1; while (x + l < COLS && grid[y][x + l].type === t) l++;
                    if (l >= 3) { for (let i = 0; i < l; i++) set.add(`${x + i},${y}`); x += l - 1; }
                }
            }
            for (let x = 0; x < COLS; x++) {
                for (let y = 0; y < ROWS - 2; y++) {
                    let t = grid[y][x].type; if (t === -1) continue;
                    let l = 1; while (y + l < ROWS && grid[y + l][x].type === t) l++;
                    if (l >= 3) { for (let i = 0; i < l; i++) set.add(`${x},${y + i}`); y += l - 1; }
                }
            }
            return Array.from(set).map(s => { let [x, y] = s.split(',').map(Number); return { x, y }; });
        }

        async function resolveMatches(matches) {
            matches.forEach(m => {
                let id = grid[m.y][m.x].id;
                let g = gems.get(id);
                g.classList.add('match');
                let rect = g.getBoundingClientRect();
                spawnParticles(rect.x + rect.width / 2, rect.y + rect.height / 2, grid[m.y][m.x].type);
            });
            score += matches.length * 50;
            if (matches.length > 4) playSound('big_match');
            updateScore(score);
            shakeWrapper();
            await sleep(300);

            matches.forEach(m => {
                let id = grid[m.y][m.x].id;
                gems.get(id).remove(); gems.delete(id);
                grid[m.y][m.x] = { type: -1, id: -1 };
            });
            await applyGravity();
        }

        async function applyGravity() {
            let moves = [];
            // Calculate drops
            for (let x = 0; x < COLS; x++) {
                let writeY = ROWS - 1;
                for (let y = ROWS - 1; y >= 0; y--) {
                    if (grid[y][x].type !== -1) {
                        if (writeY !== y) {
                            let g = gems.get(grid[y][x].id);
                            grid[writeY][x] = grid[y][x];
                            grid[y][x] = { type: -1, id: -1 };

                            // Physics Drop
                            // Using a higher gravity effect: distance squared? 
                            // Standard ease-in is okay, but bounce at end is better.
                            let dist = (writeY - y);
                            let time = 300 + (dist * 50); // scales slightly

                            g.style.transition = `transform ${time}ms cubic-bezier(0.5, 0.05, 1, 0.5)`;
                            g.style.transform = `translate(${x * 100}%, ${writeY * 100}%)`;

                            // Bounce & Clink
                            moves.push(
                                new Promise(r => setTimeout(() => {
                                    // Slight bounce visual could be complex without keyframes per element
                                    // Just Sound Clink
                                    playSound('clink');
                                    r();
                                }, time))
                            );
                        }
                        writeY--;
                    }
                }
                // Spawn
                for (let y = writeY; y >= 0; y--) {
                    let type = rnd(GEM_TYPES);
                    let id = nextId++;
                    let g = createGem(id, type, x, y);
                    container.appendChild(g); gems.set(id, g);
                    grid[y][x] = { type, id };

                    g.style.transition = 'none';
                    g.style.transform = `translate(${x * 100}%, -${(writeY - y + 1) * 100}%)`;

                    g.offsetHeight; // Reflow

                    let time = 400 + (y * 50);
                    g.style.transition = `transform ${time}ms cubic-bezier(0.5, 0.05, 1, 0.5)`;
                    g.style.transform = `translate(${x * 100}%, ${y * 100}%)`;

                    moves.push(new Promise(r => setTimeout(() => {
                        playSound('clink');
                        r();
                    }, time)));
                }
            }
            updateDataset();
            if (moves.length > 0) await Promise.all(moves);

            let newM = findMatches();
            if (newM.length > 0) {
                await sleep(150);
                await resolveMatches(newM);
            } else {
                state = 'IDLE';
            }
        }

        function updateScore(s) { scoreEl.innerText = s; }
        function shakeWrapper() {
            let w = document.getElementById('game-wrapper');
            w.classList.remove('shake-anim'); w.offsetHeight; w.classList.add('shake-anim');
        }
        const sleep = ms => new Promise(r => setTimeout(r, ms));

        // --- Audio ---
        const A = window.AudioContext || window.webkitAudioContext;
        const ac = new A();
        function playSound(t) {
            if (window.GameSettings && !window.GameSettings.get().sound) return;
            if (ac.state === 'suspended') ac.resume();
            let o = ac.createOscillator(), g = ac.createGain();
            o.connect(g); g.connect(ac.destination);
            let n = ac.currentTime;

            if (t === 'select') {
                o.frequency.setValueAtTime(400, n); g.gain.setValueAtTime(0.05, n);
                g.gain.linearRampToValueAtTime(0, n + 0.05); o.start(n); o.stop(n + 0.05);
            } else if (t === 'swap') {
                o.frequency.setValueAtTime(300, n); o.frequency.linearRampToValueAtTime(500, n + 0.1);
                g.gain.setValueAtTime(0.05, n); g.gain.linearRampToValueAtTime(0, n + 0.15);
                o.start(n); o.stop(n + 0.15);
            } else if (t === 'match') {
                o.frequency.setValueAtTime(440, n); o.frequency.linearRampToValueAtTime(880, n + 0.1);
                g.gain.setValueAtTime(0.1, n); g.gain.exponentialRampToValueAtTime(0.001, n + 0.3);
                o.start(n); o.stop(n + 0.3);
            } else if (t === 'bad') {
                o.type = 'sawtooth'; o.frequency.setValueAtTime(150, n); o.frequency.linearRampToValueAtTime(100, n + 0.2);
                g.gain.setValueAtTime(0.1, n); g.gain.linearRampToValueAtTime(0, n + 0.2);
                o.start(n); o.stop(n + 0.2);
            } else if (t === 'clink') {
                // Short high ping
                o.type = 'triangle';
                o.frequency.setValueAtTime(1200 + Math.random() * 400, n);
                g.gain.setValueAtTime(0.02, n); g.gain.exponentialRampToValueAtTime(0.001, n + 0.1);
                o.start(n); o.stop(n + 0.1);
            }
        }

        // --- FX ---
        let parts = [];
        function spawnParticles(x, y, t) {
            let c = ['#f00', '#0f0', '#00f', '#ff0', '#f0f', '#fa0', '#fff'][t];
            for (let i = 0; i < 8; i++) { parts.push({ x, y, vx: (Math.random() - 0.5) * 15, vy: (Math.random() - 0.5) * 15, l: 1, c }); }
        }
        function drawFX() {
            ctx.clearRect(0, 0, fxCanvas.width, fxCanvas.height);
            for (let i = parts.length - 1; i >= 0; i--) {
                let p = parts[i]; p.x += p.vx; p.y += p.vy; p.vy += 0.8; p.l -= 0.03;
                if (p.l <= 0) { parts.splice(i, 1); continue; }
                ctx.globalAlpha = p.l; ctx.fillStyle = p.c;
                ctx.beginPath(); ctx.arc(p.x, p.y, 4 * p.l, 0, 7); ctx.fill();
            }
            requestAnimationFrame(drawFX);
        }
        drawFX();
    </script>
</body>

</html>